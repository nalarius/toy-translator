"""Execution Engine - executes plans generated by planners."""

from __future__ import annotations

import importlib
from typing import Any, Dict, List


class ExecutionEngine:
    """Executes skill-based plans."""

    def __init__(self):
        """Initialize the execution engine."""
        # Dynamically import skill modules
        from toy_translator.skills import classification_skills
        from toy_translator.skills import grouping_skills
        from toy_translator.skills import utility_skills

        # Build skill registry
        self.skills = {}

        # Register classification skills
        for skill_name in dir(classification_skills):
            if not skill_name.startswith('_'):
                skill_func = getattr(classification_skills, skill_name)
                if callable(skill_func):
                    self.skills[skill_name] = skill_func

        # Register grouping skills
        for skill_name in dir(grouping_skills):
            if not skill_name.startswith('_'):
                skill_func = getattr(grouping_skills, skill_name)
                if callable(skill_func):
                    self.skills[skill_name] = skill_func

        # Register utility skills
        for skill_name in dir(utility_skills):
            if not skill_name.startswith('_'):
                skill_func = getattr(utility_skills, skill_name)
                if callable(skill_func):
                    self.skills[skill_name] = skill_func

        print(f"\n[Execution Engine] Initialized with {len(self.skills)} skills")

    def evaluate_condition(
        self,
        condition: str,
        context: Dict[str, Any],
    ) -> bool:
        """
        Evaluate a conditional expression.

        Args:
            condition: Condition string (e.g., "coverage < 0.9")
            context: Execution context with variables

        Returns:
            Boolean result
        """
        if not condition:
            return True

        # Simple evaluation for common patterns
        # Format: "variable operator value"
        # Examples: "coverage < 0.9", "total_rows > 100"

        try:
            # Extract variable name, operator, and value
            for op in ['<=', '>=', '==', '!=', '<', '>']:
                if op in condition:
                    parts = condition.split(op)
                    if len(parts) == 2:
                        var_name = parts[0].strip()
                        value_str = parts[1].strip()

                        # Get variable from context
                        var_value = context.get(var_name)
                        if var_value is None:
                            print(f"    âš  Variable '{var_name}' not found in context")
                            return False

                        # Parse value
                        try:
                            value = float(value_str)
                        except ValueError:
                            value = value_str.strip('"\'')

                        # Evaluate
                        if op == '<':
                            return var_value < value
                        elif op == '>':
                            return var_value > value
                        elif op == '<=':
                            return var_value <= value
                        elif op == '>=':
                            return var_value >= value
                        elif op == '==':
                            return var_value == value
                        elif op == '!=':
                            return var_value != value

            print(f"    âš  Could not parse condition: {condition}")
            return False

        except Exception as e:
            print(f"    âš  Error evaluating condition '{condition}': {e}")
            return False

    def execute_step(
        self,
        step: Dict[str, Any],
        context: Dict[str, Any],
    ) -> Any:
        """
        Execute a single plan step.

        Args:
            step: Step definition with skill name and params
            context: Execution context

        Returns:
            Step result
        """
        skill_name = step.get('skill')
        params = step.get('params', {})
        condition = step.get('condition', '')

        # Check condition
        if condition:
            should_execute = self.evaluate_condition(condition, context)
            if not should_execute:
                print(f"\n  [Skipped] {skill_name} (condition not met: {condition})")
                return None

        # Get skill function
        if skill_name not in self.skills:
            print(f"\n  âš  Skill not found: {skill_name}")
            return None

        skill_func = self.skills[skill_name]

        # Merge context and params
        # Context contains: rows, schema, classification_result, etc.
        # Params contains: skill-specific parameters
        execution_params = {**context, **params}

        print(f"\n  [Executing] {skill_name}")
        if params:
            print(f"    Params: {params}")

        # Execute skill
        try:
            result = skill_func(**execution_params)
            return result
        except Exception as e:
            print(f"    âŒ Error executing {skill_name}: {e}")
            raise

    def execute_plan(
        self,
        plan: Dict[str, Any],
        initial_context: Dict[str, Any],
    ) -> Dict[str, Any]:
        """
        Execute a complete plan.

        Args:
            plan: Plan with strategy and steps
            initial_context: Initial execution context

        Returns:
            Final execution result
        """
        print("\n" + "=" * 60)
        print("[Execution Engine] Starting plan execution")
        print("=" * 60)

        strategy = plan.get('strategy', 'N/A')
        steps = plan.get('steps', [])

        print(f"\nStrategy: {strategy}")
        print(f"Steps: {len(steps)}\n")

        # Initialize context
        context = initial_context.copy()

        # Track results from each step
        step_results = []

        # Execute each step
        for idx, step in enumerate(steps, 1):
            skill_name = step.get('skill', 'unknown')
            print(f"\n[Step {idx}/{len(steps)}] {skill_name}")

            result = self.execute_step(step, context)

            if result is not None:
                # Store result
                step_results.append({
                    'skill': skill_name,
                    'result': result,
                })

                # Update context with result
                # Common keys: classification, sessions, coverage, passed, etc.
                if isinstance(result, dict):
                    context.update(result)

        print("\n" + "=" * 60)
        print("[Execution Engine] Plan completed")
        print("=" * 60)

        return {
            'strategy': strategy,
            'steps_executed': len(step_results),
            'step_results': step_results,
            'final_context': context,
        }


def execute_classification_plan(
    plan: Dict[str, Any],
    rows: List[Dict[str, Any]],
    schema: Dict[str, Any],
) -> Dict[str, Any]:
    """
    Execute a classification plan.

    Args:
        plan: Classification plan from planner
        rows: All data rows
        schema: Column schema

    Returns:
        Classification result
    """
    engine = ExecutionEngine()

    initial_context = {
        'rows': rows,
        'schema': schema,
        'original_rows': rows,  # Some skills expect this name
    }

    execution_result = engine.execute_plan(plan, initial_context)

    # Extract classification from final context
    final_context = execution_result['final_context']
    classification = final_context.get('classification', {})
    coverage = final_context.get('coverage', 0.0)

    print(f"\nðŸ“Š Classification Summary:")
    print(f"  Total rows: {len(rows)}")
    print(f"  Coverage: {coverage:.1%}")
    print(f"  Types found: {len(classification)}")
    for type_name, indices in sorted(classification.items()):
        print(f"    {type_name}: {len(indices)} rows")

    return {
        'classification': classification,
        'coverage': coverage,
        'execution_result': execution_result,
    }


def execute_grouping_plan(
    plan: Dict[str, Any],
    dialogue_rows: List[Dict[str, Any]],
    schema: Dict[str, Any],
) -> Dict[str, Any]:
    """
    Execute a grouping plan.

    Args:
        plan: Grouping plan from planner
        dialogue_rows: Dialogue rows to group
        schema: Column schema

    Returns:
        Grouping result
    """
    engine = ExecutionEngine()

    initial_context = {
        'dialogue_rows': dialogue_rows,
        'schema': schema,
    }

    execution_result = engine.execute_plan(plan, initial_context)

    # Extract sessions from final context
    final_context = execution_result['final_context']
    sessions = final_context.get('sessions', {})

    print(f"\nðŸ“Š Grouping Summary:")
    print(f"  Total dialogue rows: {len(dialogue_rows)}")
    print(f"  Sessions created: {len(sessions)}")

    if sessions:
        session_sizes = [len(turns) for turns in sessions.values()]
        avg_size = sum(session_sizes) / len(session_sizes)
        print(f"  Avg session size: {avg_size:.1f} turns")
        print(f"  Size range: {min(session_sizes)}-{max(session_sizes)} turns")

    return {
        'sessions': sessions,
        'execution_result': execution_result,
    }
